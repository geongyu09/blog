---
title: Next란?
thumbnail: '/assets/blog/test/testThumb.jpg'
description: '간단히 Next.js의 공부 내용을 정리해보았습니다. Next의 탄생 배경 및 장점에 대한 내용을 다룹니다.'
date: '2024-03-16T05:35:07.322Z'
tags: 'next.js'
---

# history

`Vercel`이라는 회사를 통해서 2016년도에 오픈소스로 릴리즈 되었다. 이때 6가지의 원칙을 소개했다.

- out-of-the-box functionality requirign no setup | 특별한 세팅 없이 사용할 수 있어야 한다.
- javaScript everwhere | js로 모든 것을 해결할 것.(프론트 / 백엔드)
- automatic code-splitting and server-rendering | 자동으로 코드스플릿(사용자가 보는 페이지 코드부분만 잘라서 클라이언트로 보냄)과 서버렌더링을 해준다.
- configurable data-fetching | 데이터 fetching을 설정 가능하게 한다.(fetching 위치(서버, 클라)나 횟수 등)
- anticipating requests | 요청을 예상 가능하게 만들겠다. 정말 필요한 것이 무엇인지 미리 알고 요청하는 것을 예상 가능하도록 만들겠다.
- simpleifying deployment | 배포를 쉽게 하겠다.

이 원칙 내에서 조금씩 업데이트 되어젔다.

이후 2020년도에 v9.3이 릴리즈 되며서 Rewrite, Redirect, Incremental Static Generation이 나왔으며, 현재 2022년도에 13버전이 릴리즈 되어 엄청난 것이 변하게 되었다.



# React의 단점


리엑트로 웹을 만들었다면 기본적으로 CSR(client side rednering)으로 간주된다. 클라이언트에서 렌더링을 한다.

> 🍀
>
> **CSR 동작**
> 클라이언트와 서버가 있을 때 홈페이지에 접속하면, 클라이언트가 서버로 요청을 보낼 것이다. 이때 비어있는 html파일을 받아올 것이다. head에는 title과 description, body는 아에 비어있을 것이다(index.html 파일). 그러다보니 사용자가 제일 처음으로 보는 페이지는 비어있는 페이지이다. 이후 리엑트 자체 라이브러리 소스코드와 우리가 직접 만든 소스코드를 다운받는다. 그리고 리엑트 소스코드를 메모리에 넣어두고 기존 html의 root요소에 index.js를 연결시키며 차근차근 코드를 읽어가며 DOM요소로 변환하여준다. 이렇게 DOM tree를 이해하고 painting해준다. 이렇게 모든 과정을 거쳐야지만 첫 페이지를 볼 수 있다. 이렇게 모든 코드를 서버로부터 클라이언트가 받아와 클라이언트에서 렌더링을 하므로 CSR이라고 한다.

CSR 장점

- 한번 로딩되면 빠른 UX제공
- 서버의 부하가 작음

CSR 단점

- 페이지 로딩 시간(TTV_Time To View)이 길다. (FCP_First Contentful Paint 까지 오래걸린다. )
- 자바스크립트 활성화가 필수이다. 거희 모든 코드가 js로 동작하니 사용자가 js사용을 멈춰두면 웹페이지를 볼 수 없다.
- <mark>SEO(search engin optimization )최적화가 힘들다.</mark> 웹 크롤러가 웹을 돌아다니며 (title, description 등등) 분석한다. 다만 CSR의 경우 js를 모두 다운받고 분석하지 않은 이상 빈 페이지만 보게 된다.
- 보안에 취약하다. 클라이언트에 모든 코드를 올리고 실행하다보니 코드가 노출된다.
- CDN(Content Delivery Network)에 캐시가 안된다. html은 비어있고, cdn에 표기하려면 js코드를 무겁게 받아와야 하므로 어려움이 있다.

(cdn \_ 서버와 클라이언트의 물리적 거리가 멀수록 비용적(시간적)으로 좋지 않다. 이를 위해 중간지점에 서버를 두어 중간 서버에 먼저 요청을 하여 캐싱된 데이터가 있는지 물어보고, 없으면 본 서버에 요청다도록 한다. 이후 받아온 데이터는 중간 서버에 캐싱해두어 다음 접속때 속도를 높인다.)

이러한 CSR의 문제점을 해결하기 위해 나온 것이 SSG, SSR이다.



# SSG_Static Site Generation

CSR의 이러한 문제점이 결국에는 js코드를 클라이언트에 주고 클라이언트에서 페이지를 만드는 것 때문이었으니까 그럼 정적인 페이지를 만들어서 주면 어떨까? 해서 나오게 되었다. (gatby사용하면 구현할 수 있다.)

<!-- > {: .quote-warning} -->
> ⚠️
>
> SSG
> 렌더링의 시점은 서버에 배포 후 처음 빌드할 때 이다. 즉 서버에 배포 후 처음 빌드할 때 렌더링 된다. db로부터 값을 가져오거나 fetch를 사용하여 페이지를 만드는 것 또한 미리 값을 받아와 html으로 만든다. 이후 클라이언트가 요청하게 되면 바로 미리 만들어둔 html을 주게 되고 클라이언트에서는 html을 표기만 해주면 된다. 이후에 CDN에 html파일을 저장해두기도 편리하다.

SSG장점

- 페이지 로딩 시간 (TTV)이 빠르다.
- 자바스크립트가 필요 없다.
- SEO 최적화가 좋다. html을 주므로
- 보안이 뛰어나다. js코드를 보내지 않아도 되므로.
- CDN에 캐시가 된다.

단점

- 데이터가 정적이다. 빌드할 때 데이터를 받아오니까 데이터가 자주 바뀐다면 이를 바로바로 보여줄 수 없다.
- 사용자별 정보 제공이 어렵다. 이용하는 사용자가 다양하고 많다면 그 많은 종류의 페이지를 미리 만들어 두는 것은 한계가 있다.

즉 모든 사용자가 같은 페이지를 보고, 데이터가 정적이라면 좋은 방식이다.



# ISR Incremental Static Regeneration

SSG와 동일하게 렌더링은 서버가 진행한다. 기본적인 원리 또한 동일하다. 다만 렌더링을 하는 시점이 주기적이라는 것이 다르다. 빌드시에만 렌더링 하는 SSG의 단점을 보안하기 위해서 나오게 되었다.

> 💡
>
> ISR
> 기본적인 원리는 SSG와 동일하게 미리 서버에서 렌더링 후 클라이언트에 보내고, CDN에 캐싱하게 된다. 다만 렌더링을 하는 시점이 빌드시에도 하지만, 직접 정한 주기대로 렌더링을 실시하게 된다.

ISR 장점

- 페이지 로딩 시간 (TTV)이 빠르다.
- 자바스크립트가 필요 없다.
- SEO 최적화가 좋다.
- 보안이 뛰어나다.

//SSG의 장점을 모두 가진다. 추가적으로

- 데이터가 주기적으로 업데이트 됨

ISR 단점

- 여전히 실시간 데이터가 아니다.
- 사용자별 정보 제공의 어려움



# SSR Server Side Rendering

SSG, ISR과 같이 서버에서 렌더링을 진행한다. 다만 렌더링을 그때그때 요청이 들어올 때마다 실행하게 된다.

> .
>
> SSR
> 클라이언트가 서버로 요청을 보내면 서버에서 그때 db나 fetch data를 다 포함하여서 html페이지를 렌더링 해서 클라이언트로 보내주게 된다.

SSR 장점

- 페이지 로딩 시간이 빠르다.(모든 파일 다운받을 이유 없음. html만 받으므로)
- 자바스크립트 필요 없음.
- SEO 최적화 좋음
- 보안이 뛰어남
- 실시간 데이터를 사용
- 사용자별 필요한 데이터를 사용함

문제점

- SSG, ISR과 비교했을 때 상대적으로 느릴 수 있다.(아무래도 렌더링을 그때 하니까. 미리 해둔거 보내는 것보단 느림)
- 서버의 과부하가 걸릴 수 있다. 서버의 overhead가 높아진다. (요청때마다 서버가 일하니까)
- 매번 페이지를 새로 만들게 되니 CDN에 캐시가 안된다.



# Hybrid Web app

위에서 4가지의 렌더링 방식에 대해 알아보았다. 각자의 단점을 보완하기 위해서 나오기 시작했지만, 어느것 하나 완벽하지 않고, 각각의 장단점과 특징이 있었다. 웹을 만들 때 이러한 것들을 잘 알고 가장 잘 맞는 렌더링 방식을 사용하면 성능적으로 우수할 것이다.

Next.js에서는 각기다른 렌더링 방식을 혼합할 수 있다. 이를 통하여 성능좋은 강력한 웹앱을 만들 수 있다. 페이지별로 렌더링 방식을 정할 수 있고, 심지어는 한 페이지 내에서도 부분별로 렌더링 방식을 다르게 할 수 있다.

## Hydration

단어 뜻 그대로 수화시키다 이다. 물을 채우다. 불리다. 등등으로 해석할 수 있다. 말린 물티슈에 물을 부으면 점점 커지면서 물티슈가 되어 제 기능을 하게 되는 것을 생각해보자. 이 원리를 이용해서 Next는 Hybrid rendering을 구현하여 준다.

> ❌
>
> 클라이언트에서 페이지 요청을 하면 페이지(html)를 정적으로 만들어 준다(pre-rendering). 즉 의미가 있는 페이지를 빠르게 볼 수 있도록 만들어 준다. 이때는 화면은 보이지만 동작하지 않을 것이다. 이후에 리엑트 라이브러리와 소스코드를 보내준다(리엑트로 채우게 된다 = 컴포넌트 렌더링). 다운이 되면 그때부터 제대로 동작하게 된다.

예전의 next.js, 또는 잘못 만들어진 next.js 페이지를 보면 웹을 사용하다가 깜박임을 볼 수 있다. 이경우는 정적인 html페이지에 리엑트를 hydration한 그 사이에 깜박임이 발생한 것이다. 이 간극을 줄이는 것이 핵심이다.

> ❗️
>
> 웹 개발 시 중요한 포인트
> TTV : 첫 의미있는 페이지를 보기까지의 걸리는 시간
> TTI_Time To Interact : 페이지나 나온 시점부터 동작하는 시점까지 걸리는 시간

## Next.js Decition Tree

어떤 상황에서 어떤렌더링을 사용해야 하는지에 대해 간단한 tree를 생각해보자.

렌더링 방식의 주요 특징은 이와 같았다.

- 데이터가 변경되는가 ?
  - 자주 : SSR
  - 적당히 : ISR
  - 정적 : SSG ,CSR
- 사용자별 다른 페이지를 주어야 하는가?
  - o : CSR, SSR
  - x : SSG, ISR
- 보안이 필요한가?
  - o : SSG, ISR, SSR
  - x : CSR

이를 통해서 간단한 ox트리를 만들어 보면

- 사용자의 로그인이 필요한가?(사용자별 다른 페이지 줘야 하는가?)
  - yes : CSR, SSR, Hybrid(SSG | CSR)
  - no : 데이터가 얼마나 자주 변경되는가? (바로 보여줘야 하는가?)
    - 정적 : SSG
    - 적당히 : ISR
    - 자주 : SSR, Hybrid(ISR | SSG + CSR)//자주 바뀌는 부분을 ssg나 csr로 구현
